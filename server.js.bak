// server.js
require('dotenv').config();

const express = require('express');
const cors = require('cors');
const multer = require('multer');
const fs = require('fs');
const path = require('path');
const crypto = require('crypto');
const nacl = require('tweetnacl');
const util = require('tweetnacl-util');
const sharp = require('sharp'); // HEIC -> JPEG conversion
const session = require('express-session');

const app = express();

/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
 *  ADMIN CREDENTIALS (USERNAME + PASSWORD)
 * ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */

const ADMIN_USER = process.env.ADMIN_USER || 'admin';
// Backwards-compatible: allow ADMIN_PASS or old ADMIN_PASSWORD
const ADMIN_PASS =
  process.env.ADMIN_PASS || process.env.ADMIN_PASSWORD || 'changeme';

/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
 *  BASIC MIDDLEWARE
 * ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */

app.use(cors());
app.use(express.json({ limit: '20mb' }));
app.use(
  express.urlencoded({
    extended: true,
    limit: '20mb',
  })
);

app.use(
  session({
    secret: process.env.SESSION_SECRET || 'dev-secret',
    resave: false,
    saveUninitialized: false,
  })
);

/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
 *  FILE STORAGE / CLIENT KEYS
 * ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */

const uploadDir = path.join(__dirname, 'uploads');

if (!fs.existsSync(uploadDir)) {
  fs.mkdirSync(uploadDir, { recursive: true });
}

// Active chunked upload sessions
const activeChunkUploads = new Map();

// client public keys
const CLIENTS = {
  'client-1': {
    publicKeyBase64: '6+JBvOzFVqrmEWKPoMfwcTNPG9Xg4VRLbV2qiQT5gys=',
  },
};

// decode base64 keys once
for (const id in CLIENTS) {
  CLIENTS[id].publicKey = util.decodeBase64(CLIENTS[id].publicKeyBase64);
}

/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
 *  MULTER (DISK STORAGE)
 * ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */

const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, uploadDir);
  },
  filename: (req, file, cb) => {
    const ext = path.extname(file.originalname || '').toLowerCase() || '.jpg';
    const unique = Date.now() + '-' + Math.round(Math.random() * 1e9);
    cb(null, unique + ext);
  },
});

const upload = multer({
  storage,
  limits: {
    fileSize: 100 * 1024 * 1024, // 100MB
  },
});

/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
 *  SIGNATURE VERIFICATION
 * ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */

function verifyClientSignature({
  clientId,
  timestamp,
  signatureBase64,
  originalName,
}) {
  const client = CLIENTS[clientId];
  if (!client || !client.publicKey) {
    console.warn('Unknown clientId', clientId);
    return false;
  }

  if (!timestamp || !signatureBase64 || !originalName) {
    return false;
  }

  const message = `${timestamp}:${originalName}`;
  const messageBytes = util.decodeUTF8(message);
  const signatureBytes = util.decodeBase64(signatureBase64);

  return nacl.sign.detached.verify(
    messageBytes,
    signatureBytes,
    client.publicKey
  );
}

// optional HEIC -> JPEG conversion, mutates file object
async function maybeConvertHeicToJpeg(file) {
  if (!file) return;

  const ext = path.extname(file.originalname).toLowerCase();
  const isHeic =
    file.mimetype === 'image/heic' ||
    file.mimetype === 'image/heif' ||
    ext === '.heic' ||
    ext === '.heif';

  if (!isHeic) return;

  const heicPath = file.path;
  const jpegPath = heicPath.replace(/\.(heic|heif)$/i, '.jpg');

  console.log('Converting HEIC/HEIF to JPEG:', heicPath, '->', jpegPath);

  try {
    await sharp(heicPath).jpeg({ quality: 90 }).toFile(jpegPath);
    fs.unlinkSync(heicPath);

    file.filename = path.basename(jpegPath);
    file.path = jpegPath;
    file.mimetype = 'image/jpeg';
  } catch (err) {
    console.error('HEIC conversion failed:', err);
  }
}

// Very small helper for inferring a mime type from extension
function getMimeTypeFromExtension(ext) {
  const lower = (ext || '').toLowerCase();
  if (lower === '.jpg' || lower === '.jpeg') return 'image/jpeg';
  if (lower === '.png') return 'image/png';
  if (lower === '.heic' || lower === '.heif') return 'image/heic';
  return 'application/octet-stream';
}

/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
 *  HTML RENDERERS
 * ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */

function renderLoginPage(errorMessage = '') {
  return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Admin Login</title>
  <style>
    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: radial-gradient(circle at top, #111827, #020617);
      color: #e5e7eb;
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100vh;
    }
    .card {
      background: #020617;
      padding: 24px;
      border-radius: 12px;
      box-shadow: 0 20px 40px rgba(0,0,0,0.5);
      width: 320px;
      border: 1px solid #1f2937;
    }
    h1 { margin: 0 0 16px 0; font-size: 20px; }
    label { display: block; margin-top: 12px; font-size: 14px; }
    input {
      width: 100%;
      padding: 8px 10px;
      border-radius: 6px;
      border: 1px solid #374151;
      background: #030712;
      color: #e5e7eb;
      margin-top: 4px;
    }
    button {
      margin-top: 16px;
      width: 100%;
      padding: 10px;
      border-radius: 999px;
      border: none;
      background: #2563eb;
      color: white;
      font-weight: 600;
      cursor: pointer;
    }
    button:hover {
      background: #1d4ed8;
    }
    .error {
      margin-top: 12px;
      color: #f97373;
      font-size: 13px;
    }
  </style>
</head>
<body>
  <form class="card" method="POST" action="/login">
    <h1>Admin Login</h1>
    <label>
      Username
      <input name="username" autocomplete="username" autofocus />
    </label>
    <label>
      Password
      <input type="password" name="password" autocomplete="current-password" />
    </label>
    <button type="submit">Log in</button>
    ${
      errorMessage
        ? `<div class="error">${errorMessage}</div>`
        : ''
    }
  </form>
</body>
</html>`;
}

function renderDashboard({ folderNames, currentFolder, files }) {
  const folderListHtml = [
    `<div class="folder-item${!currentFolder ? ' active' : ''}" onclick="goToFolder('')">üìÅ Root</div>`,
    ...folderNames.map(name => {
      const safe = name.replace(/</g, '&lt;').replace(/>/g, '&gt;');
      const isActive = currentFolder === name;
      return `<div class="folder-item${isActive ? ' active' : ''}" onclick="goToFolder('${safe}')">üìÅ ${safe}</div>`;
    }),
  ].join('');

  const fileCardsHtml =
    files.length === 0
      ? `<div class="empty">No images yet in this folder.</div>`
      : files
          .map(file => {
            const safeName = file.name
              .replace(/</g, '&lt;')
              .replace(/>/g, '&gt;');
            const url = `/uploads${
              currentFolder ? '/' + encodeURIComponent(currentFolder) : ''
            }/${encodeURIComponent(file.name)}`;
            return `
              <div class="card"
                   draggable="true"
                   data-filename="${safeName}"
                   ondragstart="onCardDragStart(event, '${safeName}')"
                   onclick="openImage('${url}')">
                <div class="thumb-wrap">
                  <img src="${url}" />
                </div>
                <div class="meta">
                  <div class="name">${safeName}</div>
                  <div class="size">${file.sizeLabel}</div>
                </div>
              </div>
            `;
          })
          .join('');

  const folderLabel = currentFolder ? `Folder: ${currentFolder}` : 'Folder: Root';

  return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Photo Dashboard</title>
  <style>
    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: #020617;
      color: #e5e7eb;
      display: flex;
      height: 100vh;
    }
    .sidebar {
      width: 260px;
      background: #020617;
      border-right: 1px solid #1f2937;
      padding: 16px;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      gap: 16px;
    }
    .sidebar h1 {
      margin: 0;
      font-size: 18px;
    }
    .folders {
      flex: 1;
      overflow-y: auto;
      margin-top: 8px;
    }
    .folder-item {
      padding: 6px 10px;
      border-radius: 6px;
      font-size: 14px;
      cursor: pointer;
    }
    .folder-item:hover {
      background: #111827;
    }
    .folder-item.active {
      background: #1f2937;
      font-weight: 600;
    }
    .add-folder {
      margin-top: 12px;
    }
    .add-folder input {
      width: 100%;
      padding: 6px 8px;
      border-radius: 6px;
      border: 1px solid #374151;
      background: #030712;
      color: #e5e7eb;
      box-sizing: border-box;
      margin-bottom: 4px;
    }
    .add-folder button,
    .logout button {
      width: 100%;
      padding: 8px 0;
      border-radius: 999px;
      border: none;
      background: #2563eb;
      color: white;
      font-weight: 600;
      cursor: pointer;
      font-size: 13px;
    }
    .add-folder button:hover,
    .logout button:hover {
      background: #1d4ed8;
    }
    .logout {
      margin-top: auto;
    }
    .main {
      flex: 1;
      padding: 16px;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    .top-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
    }
    .current-folder {
      font-size: 15px;
    }
    .grid {
      flex: 1;
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
      gap: 16px;
      overflow-y: auto;
      padding-bottom: 8px;
    }
    .card {
      background: #020617;
      border-radius: 10px;
      border: 1px solid #1f2937;
      padding: 10px;
      cursor: grab;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .card.dragging {
      opacity: 0.4;
      border-color: #3b82f6;
      box-shadow: 0 0 0 2px #3b82f6;
    }
    .thumb-wrap {
      height: 180px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #030712;
      border-radius: 8px;
      overflow: hidden;
    }
    .thumb-wrap img {
      max-width: 100%;
      max-height: 100%;
      display: block;
    }
    .meta {
      font-size: 13px;
    }
    .meta .name {
      font-weight: 500;
      margin-bottom: 2px;
      word-break: break-all;
    }
    .meta .size {
      color: #9ca3af;
    }
    .empty {
      font-size: 14px;
      color: #9ca3af;
    }

    .folders-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 4px;
    }
    .folders-header span {
      font-size: 13px;
      color: #9ca3af;
    }

    .drop-target {
      border-radius: 6px;
      padding: 6px 10px;
    }
    .drop-target.drag-over {
      border: 1px dashed #3b82f6;
      background: #020617;
    }
  </style>
</head>
<body>
  <div class="sidebar">
    <div>
      <h1>Photo Admin</h1>
      <div class="folders-header">
        <span>Folders</span>
      </div>
      <div class="folders" id="folder-list">
        ${folderListHtml}
      </div>
      <form class="add-folder" method="POST" action="/admin/add-folder">
        <input
          type="text"
          name="folderName"
          placeholder="New folder name"
          required
        />
        <button type="submit">Add folder</button>
      </form>
    </div>
    <form class="logout" method="POST" action="/logout">
      <button type="submit">Log out</button>
    </form>
  </div>

  <div class="main">
    <div class="top-row">
      <div class="current-folder">${folderLabel}</div>
    </div>
    <div class="grid" id="file-grid">
      ${fileCardsHtml}
    </div>
  </div>

  <script>
    let dragFilename = null;

    function goToFolder(name) {
      if (!name) {
        window.location.href = '/dashboard';
      } else {
        window.location.href = '/dashboard?folder=' + encodeURIComponent(name);
      }
    }

    function openImage(url) {
      window.open(url, '_blank');
    }

    function onCardDragStart(ev, filename) {
      dragFilename = filename;
      ev.dataTransfer.effectAllowed = 'move';
      ev.dataTransfer.setData('text/plain', filename);
      ev.currentTarget.classList.add('dragging');
    }

    document.addEventListener('dragend', ev => {
      const cards = document.querySelectorAll('.card.dragging');
      cards.forEach(c => c.classList.remove('dragging'));
    });

    const folderList = document.getElementById('folder-list');
    if (folderList) {
      folderList.addEventListener('dragover', ev => {
        ev.preventDefault();
        ev.dataTransfer.dropEffect = 'move';
      });

      folderList.addEventListener('dragenter', ev => {
        const item = ev.target.closest('.folder-item');
        if (item) item.classList.add('active-drop');
      });

      folderList.addEventListener('dragleave', ev => {
        const item = ev.target.closest('.folder-item');
        if (item) item.classList.remove('active-drop');
      });

      folderList.addEventListener('drop', ev => {
        ev.preventDefault();
        const item = ev.target.closest('.folder-item');
        if (!item) return;

        const label = item.textContent || '';
               const isRoot = label.includes('Root');
        const toFolder = isRoot ? '' : label.replace(/^üìÅ\s*/, '');
        const filename = dragFilename || ev.dataTransfer.getData('text/plain');
        if (!filename) return;

        const urlParams = new URLSearchParams(window.location.search);
        const fromFolder = urlParams.get('folder') || '';

        const params = new URLSearchParams();
        params.append('filename', filename);
        params.append('fromFolder', fromFolder);
        params.append('toFolder', toFolder);

        fetch('/admin/move', {
          method: 'POST',
          headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
          body: params.toString(),
        })
          .then(() => {
            if (toFolder) {
              window.location.href = '/dashboard?folder=' + encodeURIComponent(toFolder);
            } else {
              window.location.href = '/dashboard';
            }
          })
          .catch(err => {
            console.error('Move failed', err);
            alert('Move failed');
          });
      });
    }
  </script>
</body>
</html>`;
}

function renderPortPage(currentPort, errorMessage = '') {
  return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Change Port</title>
  <style>
    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: #020617;
      color: #e5e7eb;
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100vh;
    }
    .card {
      background: #020617;
      padding: 24px;
      border-radius: 12px;
      box-shadow: 0 20px 40px rgba(0,0,0,0.5);
      width: 320px;
      border: 1px solid #1f2937;
    }
    h1 { margin: 0 0 16px 0; font-size: 20px; }
    input {
      width: 100%;
      padding: 8px 10px;
      border-radius: 6px;
      border: 1px solid #374151;
      background: #030712;
      color: #e5e7eb;
      margin-top: 4px;
    }
    button {
      margin-top: 16px;
      width: 100%;
      padding: 10px;
      border-radius: 999px;
      border: none;
      background: #2563eb;
      color: white;
      font-weight: 600;
      cursor: pointer;
    }
    button:hover { background: #1d4ed8; }
    .error {
      margin-top: 12px;
      color: #f97373;
      font-size: 13px;
    }
  </style>
</head>
<body>
  <form class="card" method="POST" action="/admin/port">
    <h1>Change Server Port</h1>
    <p>Current port: <strong>${currentPort}</strong></p>
    <label>
      New port
      <input type="number" name="port" value="${currentPort}" />
    </label>
    <button type="submit">Update port</button>
    ${
      errorMessage
        ? `<div class="error">${errorMessage}</div>`
        : ''
    }
  </form>
</body>
</html>`;
}

function renderPortUpdatedPage(oldPort, newPort) {
  return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Port Updated</title>
  <style>
    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: #020617;
      color: #e5e7eb;
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100vh;
    }
    .card {
      background: #020617;
      padding: 24px;
      border-radius: 12px;
      box-shadow: 0 20px 40px rgba(0,0,0,0.5);
      width: 340px;
      border: 1px solid #1f2937;
    }
    h1 { margin: 0 0 16px 0; font-size: 20px; }
    .link {
      color: #93c5fd;
      text-decoration: none;
      font-weight: 600;
    }
  </style>
</head>
<body>
  <div class="card">
    <h1>Port updated</h1>
    <p>Server restarted from port <strong>${oldPort}</strong> to <strong>${newPort}</strong>.</p>
    <p>
      If you are accessing this server directly, open:
      <br />
      <code>http://YOUR_HOST:${newPort}</code>
    </p>
    <p><a class="link" href="/dashboard">Go to dashboard</a></p>
  </div>
</body>
</html>`;
}

/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
 *  ADMIN AUTH
 * ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */

function requireAdmin(req, res, next) {
  if (req.session && req.session.isAdmin) return next();
  return res.redirect('/login');
}

app.get('/login', (req, res) => {
  res.send(renderLoginPage());
});

app.post('/login', (req, res) => {
  const { username, password } = req.body || {};

  const isOk = username === ADMIN_USER && password === ADMIN_PASS;

  if (isOk) {
    req.session.isAdmin = true;
    return res.redirect('/dashboard');
  }

  return res.send(renderLoginPage('Invalid username or password'));
});

app.post('/logout', (req, res) => {
  req.session.destroy(() => {
    res.redirect('/login');
  });
});

// Root -> go to dashboard or login
app.get('/', (req, res) => {
  if (req.session && req.session.isAdmin) {
    return res.redirect('/dashboard');
  }
  return res.redirect('/login');
});

/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
 *  CHUNKED UPLOAD ENDPOINTS
 * ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */

// Client side (controller.js) computes SHA-256 *over base64 strings*.
// Here we keep base64 chunks in memory, rejoin, and verify SHA256 over the
// concatenated base64 string, then decode and write the binary file.

app.post('/upload-chunk-start', async (req, res) => {
  try {
    const {
      clientId,
      timestamp,
      signatureBase64,
      originalName,
      totalChunks,
      fileSha256,
    } = req.body || {};

    if (
      !clientId ||
      !timestamp ||
      !signatureBase64 ||
      !originalName ||
      !totalChunks ||
      !fileSha256
    ) {
      return res.status(400).json({ error: 'Missing required fields' });
    }

    const ok = verifyClientSignature({
      clientId,
      timestamp,
      signatureBase64,
      originalName,
    });

    if (!ok) {
      console.warn('Invalid signature on /upload-chunk-start');
      return res.status(401).json({ error: 'Invalid signature' });
    }

    const uploadId =
      crypto.randomUUID && typeof crypto.randomUUID === 'function'
        ? crypto.randomUUID()
        : `${Date.now()}-${Math.random().toString(36).slice(2)}`;

    activeChunkUploads.set(uploadId, {
      clientId,
      originalName,
      totalChunks: Number(totalChunks),
      fileSha256,
      base64Chunks: new Array(Number(totalChunks)).fill(null),
      createdAt: Date.now(),
    });

    console.log('Chunked upload started', {
      uploadId,
      clientId,
      originalName,
      totalChunks,
    });

    return res.json({ ok: true, uploadId });
  } catch (err) {
    console.error('Error in /upload-chunk-start', err);
    return res.status(500).json({ error: 'Internal server error' });
  }
});

app.post('/upload-chunk', (req, res) => {
  try {
    const { uploadId, chunkIndex, chunkSha256, chunkDataBase64 } =
      req.body || {};

    if (
      !uploadId ||
      typeof chunkIndex === 'undefined' ||
      !chunkSha256 ||
      !chunkDataBase64
    ) {
      return res.status(400).json({ error: 'Missing required fields' });
    }

    const session = activeChunkUploads.get(uploadId);
    if (!session) {
      return res.status(400).json({ error: 'Unknown uploadId' });
    }

    const index = Number(chunkIndex);
    if (!Number.isInteger(index) || index < 0 || index >= session.totalChunks) {
      return res.status(400).json({ error: 'Invalid chunkIndex' });
    }

    const computedSha = crypto
      .createHash('sha256')
      .update(chunkDataBase64)
      .digest('hex');

    if (computedSha !== chunkSha256) {
      console.warn('Chunk checksum mismatch', {
        uploadId,
        index,
        expected: chunkSha256,
        actual: computedSha,
      });
      return res.status(400).json({ error: 'Chunk checksum mismatch' });
    }

    session.base64Chunks[index] = chunkDataBase64;
    session.lastUpdated = Date.now();

    return res.json({ ok: true, receivedIndex: index });
  } catch (err) {
    console.error('Error in /upload-chunk', err);
    return res.status(500).json({ error: 'Internal server error' });
  }
});

app.post('/upload-chunk-complete', async (req, res) => {
  try {
    const { uploadId } = req.body || {};
    if (!uploadId) {
      return res.status(400).json({ error: 'Missing uploadId' });
    }

    const session = activeChunkUploads.get(uploadId);
    if (!session) {
      return res.status(400).json({ error: 'Unknown uploadId' });
    }

    const missing = [];
    for (let i = 0; i < session.totalChunks; i++) {
      if (!session.base64Chunks[i]) missing.push(i);
    }

    if (missing.length) {
      return res.status(400).json({
        error: 'Missing chunks',
        missing,
      });
    }

    const base64Full = session.base64Chunks.join('');
    const actualSha = crypto.createHash('sha256').update(base64Full).digest('hex');

    if (actualSha !== session.fileSha256) {
      console.warn('Final SHA256 mismatch on chunked upload', {
        uploadId,
        expected: session.fileSha256,
        actual: actualSha,
      });
      activeChunkUploads.delete(uploadId);
      return res.status(400).json({ error: 'Final checksum mismatch' });
    }

    const fileBuffer = Buffer.from(base64Full, 'base64');

    const ext = path.extname(session.originalName) || '.jpg';
    const unique = Date.now() + '-' + Math.round(Math.random() * 1e9);
    const finalFilename = unique + ext;
    const finalPath = path.join(uploadDir, finalFilename);

    fs.writeFileSync(finalPath, fileBuffer);

    const file = {
      path: finalPath,
      filename: finalFilename,
      originalname: session.originalName,
      mimetype: getMimeTypeFromExtension(ext),
    };

    await maybeConvertHeicToJpeg(file);

    activeChunkUploads.delete(uploadId);

    console.log('Chunked upload completed', {
      uploadId,
      filename: file.filename,
      originalName: file.originalname,
    });

    return res.json({
      status: 'ok',
      verified: true,
      filename: file.filename,
      originalname: file.originalname,
      mimetype: file.mimetype,
      url: `/uploads/${file.filename}`,
    });
  } catch (err) {
    console.error('Error in /upload-chunk-complete', err);
    return res.status(500).json({ error: 'Internal server error' });
  }
});

/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
 *  STANDARD UPLOAD ENDPOINT (NON-CHUNKED)
 * ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */

app.post('/upload', (req, res) => {
  upload.single('photo')(req, res, async err => {
    if (err) {
      console.error('Upload middleware error:', err);
      return res
        .status(500)
        .json({ error: 'Upload failed in middleware', details: err.message });
    }

    try {
      const { clientId, timestamp, signatureBase64 } = req.body;

      if (!req.file) {
        return res.status(400).json({ error: 'No file uploaded' });
      }

      if (!clientId || !timestamp || !signatureBase64) {
        try {
          fs.unlinkSync(req.file.path);
        } catch (_) {}
        return res.status(400).json({ error: 'Missing auth fields' });
      }

      const isValid = verifyClientSignature({
        clientId,
        timestamp,
        signatureBase64,
        originalName: req.file.originalname || req.file.filename,
      });

      if (!isValid) {
        console.warn('Invalid signature for upload');
        try {
          fs.unlinkSync(req.file.path);
        } catch (_) {}
        return res.status(401).json({ error: 'Invalid signature or client' });
      }

      await maybeConvertHeicToJpeg(req.file);

      console.log(
        'Saved file:',
        req.file.filename,
        'original:',
        req.file.originalname
      );

      return res.json({
        status: 'ok',
        filename: req.file.filename,
        originalname: req.file.originalname,
        mimetype: req.file.mimetype,
        url: `/uploads/${req.file.filename}`,
      });
    } catch (handlerErr) {
      console.error('Upload handler error:', handlerErr);
      return res.status(500).json({ error: 'Server error' });
    }
  });
});

/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
 *  STATIC FILES (SECURED)
 * ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */

app.use('/uploads', requireAdmin, express.static(uploadDir));

/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
 *  FOLDERS / DASHBOARD HELPERS
 * ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */

function sanitizeFolderName(name) {
  const raw = String(name || '').trim();
  if (!raw) return '';
  if (raw.includes('..') || raw.includes('/') || raw.includes('\\')) {
    return '';
  }
  return raw;
}

function safeJoinUploadDir(subfolder) {
  const base = subfolder ? path.join(uploadDir, subfolder) : uploadDir;
  const resolved = path.resolve(base);
  const root = path.resolve(uploadDir);
  if (!resolved.startsWith(root)) {
    throw new Error('Unsafe path');
  }
  return resolved;
}

function listRootFolders() {
  const entries = fs.readdirSync(uploadDir, { withFileTypes: true });
  return entries
    .filter(d => d.isDirectory())
    .map(d => d.name)
    .sort();
}

function listFilesInFolder(folder) {
  const dir = safeJoinUploadDir(folder);
  if (!fs.existsSync(dir)) {
    return [];
  }
  const entries = fs.readdirSync(dir, { withFileTypes: true });
  return entries
    .filter(d => d.isFile())
    .map(d => {
      const filePath = path.join(dir, d.name);
      const stat = fs.statSync(filePath);
      const sizeKb = stat.size / 1024;
      const sizeLabel =
        sizeKb < 1024
          ? `${sizeKb.toFixed(0)} KB`
          : `${(sizeKb / 1024).toFixed(1)} MB`;
      return {
        name: d.name,
        size: stat.size,
        sizeLabel,
      };
    })
    .sort((a, b) => a.name.localeCompare(b.name));
}

/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
 *  ROUTES: DASHBOARD / FOLDERS
 * ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */

app.get('/dashboard', requireAdmin, (req, res) => {
  const rawFolder = req.query.folder || '';
  const currentFolder = sanitizeFolderName(rawFolder);

  let baseDir;
  try {
    baseDir = currentFolder ? safeJoinUploadDir(currentFolder) : uploadDir;
  } catch {
    return res.status(400).send('Invalid folder');
  }

  if (!fs.existsSync(baseDir)) {
    fs.mkdirSync(baseDir, { recursive: true });
  }

  const folderNames = listRootFolders();
  const files = listFilesInFolder(currentFolder);

  res.send(
    renderDashboard({
      folderNames,
      currentFolder,
      files,
    })
  );
});

app.post('/admin/add-folder', requireAdmin, (req, res) => {
  const folderName = sanitizeFolderName(req.body.folderName || '');
  if (!folderName) {
    return res.redirect('/dashboard');
  }
  try {
    const dir = safeJoinUploadDir(folderName);
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true });
    }
  } catch (err) {
    console.error('Failed to create folder', err);
  }
  res.redirect('/dashboard?folder=' + encodeURIComponent(folderName));
});

app.post('/admin/move', requireAdmin, (req, res) => {
  const filename = req.body.filename || '';
  const fromFolder = sanitizeFolderName(req.body.fromFolder || '');
  const toFolder = sanitizeFolderName(req.body.toFolder || '');

  if (!filename) {
    return res.status(400).send('Missing filename');
  }

  try {
    const fromDir = safeJoinUploadDir(fromFolder);
    const toDir = safeJoinUploadDir(toFolder);

    if (!fs.existsSync(toDir)) {
      fs.mkdirSync(toDir, { recursive: true });
    }

    const src = path.join(fromDir, filename);
    const dest = path.join(toDir, filename);

    if (!fs.existsSync(src)) {
      return res.status(404).send('File not found');
    }

    fs.renameSync(src, dest);
    res.redirect('back');
  } catch (err) {
    console.error('Move failed', err);
    res.status(500).send('Move failed');
  }
});

/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
 *  PORT CHANGE
 * ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */

let currentPort = parseInt(process.env.PORT, 10) || 4000;
let server = null;

app.get('/admin/port', requireAdmin, (req, res) => {
  res.send(renderPortPage(currentPort));
});

app.post('/admin/port', requireAdmin, (req, res) => {
  const rawPort = req.body.port;
  const newPort = parseInt(rawPort, 10);

  if (!newPort || newPort < 1 || newPort > 65535) {
    return res.send(renderPortPage(currentPort, 'Invalid port number'));
  }

  if (newPort === currentPort) {
    return res.send(
      renderPortPage(currentPort, 'Port is already set to this value')
    );
  }

  const oldPort = currentPort;

  if (server) {
    console.log('Closing existing server on port', oldPort);
    server.close(() => {
      console.log('Server closed on port', oldPort);
      currentPort = newPort;
      server = app.listen(currentPort, () => {
        console.log('Server restarted on port', currentPort);
      });
    });
  } else {
    currentPort = newPort;
    server = app.listen(currentPort, () => {
      console.log('Server started on port', currentPort);
    });
  }

  res.send(renderPortUpdatedPage(oldPort, newPort));
});

/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
 *  START SERVER
 * ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */

server = app.listen(currentPort, () => {
  console.log('Server listening on port', currentPort);
});
